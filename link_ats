#! /router/bin/perl5

# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
#                            link_ats.pl
#
# This script is written for sisu-reg, to let multiple users
# share a single central ATS tree.  This script creates symbolic links
# from the central ATS repository to the user's local tree.
#
# To install a local ATS tree based of the sisu-reg's shared
# tree:
#
#    1. Create the directory where you want your local ATS tree to
#       reside.
#
#    2. Start
#          $ script <a-file>
#       where <a-file> is the file where the session log will be saved.
#
#    3. Set AUTOTEST environment variable to point to the directory
#       you have created in step 1.
#          $ setenv AUTOTEST <your-local-ats-path>
#
#    4. Run this script.
#          $ /auto/vwsqij/sisu-reg/tools/link_ats.pl
#
#    5. After the script runs to completion, exit and take a look at
#       the saved session info in <a-file>.
#
#
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#==============================================================================
# Find the basename on the command name and initialize valiables
#------------------------------------------------------------------------------
($cmd = $0) =~ s:.*/::;
$override = 0;

#==============================================================================
# Basic asruments validation
#------------------------------------------------------------------------------
while (@ARGV) {
    $word = shift;
    if ($word =~s/^-//) {
        $option = $word;
        if ($option =~ /^sh?a?r?e?d?$/) {
            $DEF_SHARED_ATS_PATH = shift;
            die "$cmd: -$option: missing shared tree path\n"
                unless (defined $DEF_SHARED_ATS_PATH);
        } elsif ($option =~ /^lo?c?a?l?$/) {
            $DEF_LOCAL_ATS_PATH = shift;
            die "$cmd: -$option: missing local tree path\n"
                unless (defined $DEF_LOCAL_ATS_PATH);
        } elsif ($option =~ /^ov?e?r?i?d?e?$/) {
            $override = 1;
        } elsif ($option =~ /^he?l?p?$/) {
          print "\nUsage: $cmd [options]\n\n";
          print "where options include:\n";
          print " -shared <shared tree path> default /auto/vwsqij/sisu-reg/ats3.5.0\n";
          print " -local <local tree path>   default $ENV{AUTOTEST}\n";
          print " -override                  By default, existing links are\n";
          print "                            not changed except for platform\n";
          print "                            specific directories. Use this\n";
          print "                            option to relink everything.\n";
          print " -help                      Show this help screen\n\n";
          exit 0;
        } else {
            die "$cmd: -$option: unknown switch\n";
        }
    } else {
        print "\nUsage: $cmd [options]\n";
        die   "       $cmd -help\n\n";
    }
}

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# This is where the sisu-regression's shared ATS tree currently is.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

$DEF_SHARED_ATS_PATH = "/auto/vwsqij/sisu-reg/ats3.5.0"
    unless (defined $DEF_SHARED_ATS_PATH);

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Assume that the user's environment variable AUTOTEST points to where
# he wanted his local ATS tree.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

$user = (getpwuid($<))[0];
$ENV{AUTOTEST} = "/auto/vwsqij/sisu-reg/$user" if (! defined $ENV{AUTOTEST});
$DEF_LOCAL_ATS_PATH = $ENV{'AUTOTEST'} if (! defined $DEF_LOCAL_ATS_PATH);
mkdir("$DEF_LOCAL_ATS_PATH", 0755) if (! -e $DEF_LOCAL_ATS_PATH);

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# For access to other sisu-regression related files.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

$SISU_REG_PATH = "/auto/vwsqij/sisu-reg"
    unless (defined $SISU_REG_PATH);

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Initialize the directory lists.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

@protect_directories =
    ('doc', 'etc', 'install', 'man', lib, 'misc', 'perllib', 'regression', 'bin', 'ats_lib', 'at
s_easy');

@platform_special_dirs = ('mibs');

#@platform_special_files = ('lib/dload');

@user_directories  = ('etc', 'lib', 'tests', 'suites');

@local_directories =
    ('logs', 'pause', 'var', 'motd', 'database', 'images', 'archive');

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Print script starter message.  The idea is, if the script output is
# saved, it helps find when the last link-ats was done.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

chop($script_name = `basename $0`);
@start_time = localtime(time);
&log_msg ('info',
          "Started on $start_time[4]-$start_time[3]-$start_time[5] ",
          "at $start_time[2]:$start_time[1]:$start_time[0]");

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Parse command-line parameters, and validate the shared and local ATS
# tree paths.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

$shared_ats = $DEF_SHARED_ATS_PATH;
$local_ats  = $DEF_LOCAL_ATS_PATH;

if ($shared_ats eq '' || ! -d $shared_ats) {
    &log_msg ('die', "Could not find directory <$shared_ats>.");
}

if ($local_ats eq '' || ! -d $local_ats) {
    &log_msg ('die', "Could not find directory <$local_ats>.");
}

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Get the OS (i.e., platform) details.  Give a chance to the user to
# overwrite it.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

$os  = `uname -s`;
$rev = `uname -r`;
$all = `uname -a`;

@platforms_supported = ('sunos4', 'sunos5', 'sunos5_x86');

if ($os =~ /^SunOS/) {
    if ($rev =~ /^4/) {
        $platform = "sunos4";
    } elsif ($rev =~ /^5/ || $all =~ /sparc/ || $all =~ /Ultra/) {
        $platform = "sunos5";
    } elsif ($all =~ /i386/) {
        $platform = "sunos5_x86";
    }
}

while (1) {
    &log_msg ('prompt',
             "Enter platform to configure your ATS for ",
             "[Default = $platform]:");
    $answer = <STDIN>;
    chop $answer;
    last if ($answer eq '' && $platform ne '');
    last if (grep(/^$answer$/, @platforms_supported));
    &log_msg ('info', "Supported platforms are",
             join(', ', @platforms_supported));
}

&log_msg ('info', "Creating an ATS tree at $local_ats \n",
          "based on shared tree at $shared_ats \n",
          "for the platform $platform ....\n\n");


# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# First create links in local ATS to the shared ATS.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

&log_msg ('info', "Linking the local ATS tree to the shared tree.\n");

# Link all "protected directories" to the same directories in the
# shared repository.  If a directory already exists, just leave it
# that way.  This gives the users the flexibility of having locally
# different ATS tree.

foreach $dir (@protect_directories) {
    if (!-e "$local_ats/$dir" || $override) {
        symlink("$shared_ats/$dir", "$local_ats/$dir");
        &log_msg ('info', "$local_ats/$dir ==> $shared_ats/$dir\n");
    } else {
        &log_msg ('warn', "$local_ats/$dir already exists.\n");
    }
}

# Link platform specific directories to the corresponding ones in the
# shared repository.

foreach $dir (@platform_special_dirs) {
    $tempname = readlink("$local_ats/$dir");

    # If this directory is not a symbolic link, skip it.  But log a
    # message to alert the user.

    if (-e "$local_ats/$dir" && !defined($tempname)) {
        &log_msg ('warn', "$local_ats/$dir already exists.\n");
    } else {

        if ($tempname ne "$shared_ats/$dir.$platform") {
            unlink("$local_ats/$dir");
            symlink("$shared_ats/$dir.$platform","$local_ats/$dir");
            &log_msg ('info',
                      "$local_ats/$dir ==> $shared_ats/$dir.$platform\n");
        } else {
            &log_msg ('info', "$local_ats/$dir already properly linked.\n");
        }
    }
}

if (! -e "$shared_ats/bin.$platform/expect") {
    if (! -w "$shared_ats/bin.$platform" ||
        ! -x "$shared_ats/bin.$platform") {
        &log_msg('die', "File $shared_ats/bin.$platform/expect \n",
                 "does not exist in the shared tree.  You do not have \n",
                 "write permissions.  Please contact the maintainer to \n",
                 "have expect linked to expectk.\n");
    } else {

        make_relative_link("$shared_ats/bin.$platform/expectk",
                           "$shared_ats/bin.$platform/expect");

    }
}

# Create the platform specific files.  For expect to run,
# $AUTOTEST/lib/dload should point to the correct platform specific file.

foreach $file (@platform_special_files) {

    local(@temp) = split(m;/;, $file);
    pop(@temp);
    local($dir)  = join('/', @temp);

    #if (-l "$local_ats/$dir") {
        #unlink("$local_ats/$dir");
    #}

    if (!-e "$local_ats/$dir") {
        mkdir("$local_ats/$dir", 0777) ||
            &log_msg ('die', "Cannot mkdir $local_ats/$dir -- $!\n");
    }

    opendir(tempdir, "$shared_ats/$dir");
    @temp_file_list = readdir(tempdir);
    closedir(tempdir);

    foreach $file_name (@temp_file_list) {
        next if ($file_name eq CVS || $file_name eq '.');
        if (-l "$local_ats/$dir/$file_name") {
            unlink("$local_ats/$dir/$file_name");
        }

        if (!-e "$local_ats/$dir/$file_name") {
            symlink("$shared_ats/$dir/$file_name",
                    "$local_ats/$dir/$file_name");
            &log_msg ('info', "$local_ats/$dir/$file_name ==> ",
                      "$shared_ats/$dir/$file_name \n");
        }
    }

    unlink("$local_ats/$file");
    symlink("$shared_ats/$file.$platform", "$local_ats/$file");
    &log_msg ('info',
             "$local_ats/$file ==> $shared_ats/$file.$platform\n");
}

symlink("$shared_ats/VERSION","$local_ats/VERSION");
&log_msg ('info', "$local_ats/VERSION ==> $shared_ats/VERSION\n");

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Create links in the $local_ats/local directory, just like autons'
# install script does.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

&log_msg ('info',
         "\nCreating links from the $local_ats/local directory\n\n\n");

# Create the $AUTOTEST/local directory tree.  Leave alone the sub
# directories that already exist.

local($localdir) = "$local_ats/local";
if (! -e $localdir) {
    chmod 0755, $local_ats;
    mkdir($localdir,0777) ||
        &log_msg ('die', "Cannot mkdir $localdir -- $!\n");
    &log_msg ('info', "Created $localdir\n");
}

foreach $dir (@local_directories) {
    local($newdir) = "$local_ats/local/$dir";
    if (!-e $newdir) {
        mkdir($newdir,0777) ||
            &log_msg ('die', "Cannot mkdir $newdir -- $!\n");
        &log_msg ('info', "Created $newdir\n");
    } else {
        &log_msg ('info', "$newdir already exists\n");
    }
}

# Recursively link regression tree into local tree

foreach $dir (@user_directories) {
    local($newdir) =  "$local_ats/local/$dir";
    if (!-e $newdir) {
        mkdir($newdir, 0777) ||
            &log_msg('die', "Cannot mkdir $newdir\n");
        &log_msg ('info', "Created $newdir\n");
    } else {
        &log_msg ('info', "$newdir already exists\n");
    }
    &link_recursively("$local_ats/regression/$dir", $newdir);

    if ($dir eq "etc" && !-e "$local_ats/local/$dir/testbed_clean.default") {
        &make_relative_link("$local_ats/local/$dir/clean",
            "$local_ats/local/$dir/testbed_clean.default");
    }
}

&link_recursively("$local_ats/lib/expect", "$local_ats/local/lib");
&link_recursively("$local_ats/etc","$local_ats/local/etc");

foreach $dirname ('lib/csccon', 'bin') {
    if (!-e "$local_ats/local/$dirname") {
        mkdir("$local_ats/local/$dirname", 0777) ||
            &log_msg('die', "Cannot mkdir $local_ats/local/$dirname");
    }
    &link_recursively("$local_ats/$dirname",
                      "$local_ats/local/$dirname");
}

if (!-e "$local_ats/local/bin/expect") {
    &make_relative_link("$local_ats/bin/expect",
                        "$local_ats/local/bin/expect");
}

&log_msg ('info', "\n\nInstallation completed successfully.\n");

if (! -e "$local_ats/local/CONFIG") {
    system("cp $SISU_REG_PATH/doc/CONFIG.SHARED $local_ats/local/CONFIG");
    &log_msg ('info', "\n
$SISU_REG_PATH/doc/CONFIG.SHARED has been copied to
$local_ats/local/CONFIG for you.\n
Please edit it to customize, before start using autotest.\n");
}

exit 0;

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Subroutine syntax : link_recursively <old> <new>
#
# Description :
#    Recursively link directory <new> to directory <old>.  For each
#    file, if it already exists in <new> leave it that way, otherwise,
#    create a link.
#
# Parameters :
#    <old>        - path of the directory to create links to
#    <new>        - path of the directory to create links from.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

sub link_recursively {
    local($old, $new) = @_;
    &log_msg ('die', "sub link_recursively : empty dir names")
        if ($old eq '' || $new eq '');

    # Get the list of all files/subdirectories in <old>.

    opendir(OLD, $old) || &log_msg ('die', "Cannot open $old -- $!\n");
    local(@files) = readdir(OLD);
    closedir(OLD);

    # Process each file/subdirectory.

    &log_msg('info', "Recursively linking $new ==> $old.\n");

    foreach $entry (@files) {
        next if substr($entry, 0, 1) eq '.';
        next if -d "$old/$entry" && $entry eq "CVS";

        if (-f "$old/$entry") {
            if (-e "$new/$entry") {
                next;
            }
            &make_relative_link("$old/$entry", "$new/$entry") ||
               &log_msg ('warn',
                        "Cannot link $old/entry to $new/$entry -- $!\n");
        } else {
            if (! -d "$new/$entry") {
                mkdir("$new/$entry",0777) ||
                    &log_msg ('warn', "Cannot mkdir $new/$entry -- $!\n");
                &log_msg ('info', "Created $new/$entry\n");
            }
            &link_recursively("$old/$entry", "$new/$entry");
        }
    }
}

sub make_relative_link {
    local($old, $new) = @_;

    local(@opath) = split(m;/;, $old);
    local(@npath) = split(m;/;, $new);

    while ($opath[0] eq $npath[0]) {
        shift @opath;
        shift @npath;
    }

    for ($i = 1; $i <= $#npath; $i ++) {
        unshift(@opath, '..');
    }

    local($o) = join('/', @opath);

    symlink($o, $new) ||
        &log_msg ('warn', "Cannot link $o to $new -- $!\n");
}

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# Subroutine Syntax : &log_msg(<sev>, <msg>)
#
# Description : Depending on the <sev>, <msg> is logged to STDOUT or
#    STDERR.  If the <sev> is 'die', program immediately exits.
#
# Parameters :
#    <sev>      - message severity (could be 'prompt', 'info', 'warn',
#                 or 'die').
#    <msg>      - message to be displayed.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

sub log_msg {
    local($sev, @msg) = @_;

    local($sec, $min, $hour) = localtime(time);
    $prefix = sprintf('%s[%2d:%2d:%2d][%s] ',
                      $script_name, $hour, $min, $sec, $sev);
    if ($sev eq 'info') {
        print STDOUT $prefix, @msg, "\n";
    } elsif ($sev eq 'prompt') {
        print STDOUT $prefix, @msg;
    } elsif ($sev eq 'warn') {
        warn $prefix, @msg, "\n";
    } elsif ($sev eq 'die') {
        die $prefix, @msg, "\n";
    } else {
        die $prefix, "log_msg called with wrong parameters : $sev";
    }
}

# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
# End of : link_ats.pl.
# ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

