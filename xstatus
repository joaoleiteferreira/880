#!/bin/sh

#==============================================================================
# To monitor currently running tests for the tree pointed to by $AUTOTEST
#------------------------------------------------------------------------------
# Kuntal Daftary                                   Fri Feb 20 18:04:01 PST 1998
#==============================================================================

#==============================================================================
# Starter kludge
#------------------------------------------------------------------------------
set starter { ${1:+"$@"}
    shift
    shift
    export AUTOTEST
    AUTOTEST="${AUTOTEST-/autons/autotest}"
    exec $AUTOTEST/bin/expectk -f $0 -- ${1:+"$@"}
}

log_user 0

global env
global withdrawn
global text

set text {}
message .status_gui -text $text \
    -font -misc-fixed-medium-r-normal--13-90-72-*-c-55-iso8859-1 \
    -aspect 300 \
    -relief flat \
    -borderwidth 0 \
    -bg #000000 \
    -width 560 \
    -fg #ffffff
pack .status_gui
wm geom . +1+1
wm title . "Status of currently running tests for $env(USER)"
wm withdraw .
update
after 1 update_text
after 1 update_window

proc repeat {str times} {
    set retStr {}
    incr times
    while { [incr times -1] } { append retStr $str }
    return $retStr
}

proc update_text {} {
    global text

    catch { set l_text [get_text] }
    if [info exists l_text] {
        set l_text "[repeat {-} 79]\n${l_text}"
	set l_text "TESTBED   CUR PPP FFF AAA TTT CLN\n$l_text"
	set l_text "  [format {%-42s} {TEST}] $l_text"
        set l_text "[repeat {=} 79]\n${l_text}"
	set text $l_text
        .status_gui config -text $text
    } else {
        set text {}
    }
    after 60000 update_text
}

proc update_window {} {
    global text
    if { ![winfo ismapped .] && [string length $text] > 0 } {
        wm deicon .
        .status_gui config -text $text
    } elseif { [winfo ismapped .] && [string length $text]<=0 } {
        wm withdraw .
    }
    after 1000 update_window
}

proc get_text {} {
    global env
    
    for_recursive_glob file $env(AUTOTEST)/local/var {*.ckp} {
        set INFO(image) "" ; set INFO(testbed) "" ; set INFO(total) "" ;
        set INFO(cleans) "" ; set INFO(pass) "" ; set INFO(fail) "" ;
        set INFO(abort) "" ; set INFO(current) "" ; set INFO(status) "" ;
        for_file line $file {
	    if [regexp "^Image: \(.*\)" $line junk image] {
	        set INFO(image) $image
	    }
	    if [regexp "^Testbed: \(.*\)" $line junk testbed] {
	        set INFO(testbed) $testbed
	    } 
	    if [regexp "Current Test: \(.*\)" $line junk current] {
	        set INFO(current) $current
	    } 
	    if [regexp "^Total Tests: \(.*\)" $line junk total] {
	        set INFO(total) $total
	    } 
	    if [regexp "^Cleans: \(.*\)" $line junk cleans] {
	        set INFO(cleans) $cleans
	    } 
	    if [regexp "^Passes: \(.*\)" $line junk pass] {
	        set INFO(pass) $pass
	    } 
	    if [regexp "^Fails: \(.*\)" $line junk fail] {
	        set INFO(fail) $fail
	    } 
	    if [regexp "^Aborts: \(.*\)" $line junk abort] {
	        set INFO(abort) $abort
	    } 
	    if [regexp "^Status: \(.*\)" $line junk status] {
	        set INFO(status) $status
	    }
	}
	append ret_text [format "%-42s   " $INFO(image)]
	append ret_text [format "%-7s   " $INFO(testbed)]
	append ret_text [format "%3d " $INFO(current)]
	append ret_text [format "%3d " $INFO(pass)]
	append ret_text [format "%3d " $INFO(fail)]
	append ret_text [format "%3d " $INFO(abort)]
	append ret_text [format "%3d " $INFO(total)]
	append ret_text [format "%3d" $INFO(cleans)]
	append ret_text [format "%78s\n" $INFO(status)]
	append ret_text "----------------------------------------"
	append ret_text "---------------------------------------\n"
    }
    return $ret_text
}
