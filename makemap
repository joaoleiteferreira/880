#!/bin/sh

#==============================================================================
# Makes a map file for a testbed
# Inspired by "checkmap" by Paras Trivedi
#------------------------------------------------------------------------------
# Kuntal Daftary                                   Sat Feb 21 02:21:26 PST 1998
#==============================================================================

#==============================================================================
# Starter kludge
#------------------------------------------------------------------------------
set starter { ${1:+"$@"}
    shift
    shift
    export AUTOTEST
    AUTOTEST="${AUTOTEST-/autons/autotest}"
    exec $AUTOTEST/bin/expect -f $0 -- ${1:+"$@"}
}

global INT LOCK_DIR
#==============================================================================
# Define procedures
#------------------------------------------------------------------------------
proc die {mesg exitStatus} {
    global LOCK_DIR

    puts stderr $mesg
    if { ![catch {set lId [open "${LOCK_DIR}/${testbed}.lock"]} err] } {
        set pid [gets $lId]
        close $lId
        if { $pid == [pid] } {
            if { ![catch {unlink "${LOCK_DIR}/${testbed}.lock"} errMsg] } {
                puts stderr "$self: Failed to remove my lock file"
            }
        } else {
	    puts stderr "$self: Lock file exists by some other process"
	}
    } else {
        puts stderr "$self: die: $err"
    }
    exit $exitStatus
}

proc warn {mesg} {
    puts stderr $mesg
}

proc repeat {str times} {
    set retStr {}
    incr times
    while { [incr times -1] } { append retStr $str }
    return $retStr
}

proc matchInt {rtr int} {
    global INT
    foreach interface $INT($rtr) {
        regsub {^([^0-9/]+)([0-9](.*[0-9])?)$} $int {^\1[^0-9/]*\2$} tint
        if { [regexp $tint $interface] } {
            return $interface
        }
    }
    return $int
}

proc commonStr {str1 str2} {
    set i 0
    while { [string range $str1 $i $i] == [string range $str2 $i $i] } {
        incr i
    }
    return [string range $str1 0 [incr i -1]]
}

#==============================================================================
# Find the basename on the command name and initialize valiables
#------------------------------------------------------------------------------
global self; regsub {.*\/} [shift argv] {} self

#==============================================================================
# Option and arguments parsing
#------------------------------------------------------------------------------
while { [llength $argv] } {
    if [regsub -- {^-} [shift argv] {} option] {
        if [regexp {^he?l?p?$} $option] {
            warn "\nUsage: $self <testbed>"
            warn "       $self -help"
	    warn ""
            exit 0
        } else {
            die "$self: -$option: unknown switch" 1
        }
    } else {
        lappend newArgv $option
    }
}
if { ![info exists newArgv] || ([llength $newArgv] < 1) } {
    die "$self: Missing testbed" 1
}
set testbed [lindex $newArgv 0]
set mapFile "${testbed}.MAP"

#==============================================================================
# Make sure that there is no scope of overwriting an existing file
#------------------------------------------------------------------------------
if { [file exists "${testbed}.MAP"] } {
  die "$self: ${testbed}.MAP: File exists" 1
}

#==============================================================================
# Source required library files and config files
#------------------------------------------------------------------------------
source $expect_library/csccon/csccon.exp
set env(_ATS_TESTBED) $testbed
ats_read_config 

#==============================================================================
# Make sure that the testbed exists
#------------------------------------------------------------------------------
if ![info exists ROUTERS($testbed)] {
    die "$self: $testbed: No such testbed" 1
}

#==============================================================================
# Set the name of the lock directory
#------------------------------------------------------------------------------
if ![info exists LOCK_DIR] {
    set LOCK_DIR {/tmp/autotest.locks}
}

#==============================================================================
# Lock the testbed if not already locked, otherwise die
#------------------------------------------------------------------------------
if { ![file exists "${LOCK_DIR}/${testbed}.lock"] } {
    if { [catch {set lId [open "${LOCK_DIR}/${testbed}.lock" w]} errMsg] } {
        warn "$self: Failed to make lock file: ${LOCK_DIR}/${testbed}.lock\n"
    }
    puts $lId [pid]
    close $lId
} else {
    die "$self: $testbed: Testbed is in use. Try again later." 1
}

#==============================================================================
# Set defaults
#------------------------------------------------------------------------------
EnablePw lab
log_user 0
set rtrRegexp [join $ROUTERS($testbed) "|"]
set intRegexp {^([^ ]+) +([^ ]+) ?([^ ]+).* ([^ ]+[^ ]+)$}

#==============================================================================
# Loop thru each router in the testbed for the first pass
#------------------------------------------------------------------------------
foreach router $ROUTERS($testbed) {

    #==========================================================================
    # Telnet to the router
    #--------------------------------------------------------------------------
    puts -nonewline "Telnetting to $router... "
    if [catch { console $router } errMsg] {
        die "failed.\n\n$self: $errMsg" 1
    }
    puts "succeeded."

    #==========================================================================
    # Apply postconfig to the router first
    #--------------------------------------------------------------------------
    puts -nonewline "Applying postconfig to $router... "
    if [catch { $router config $postconfig($router) } errMsg] {
        die "failed.\n\n$self: $errMsg" 1
    }
    puts "succeeded."

    #==========================================================================
    # Find out all the existing interfaces on that router
    #--------------------------------------------------------------------------
    puts -nonewline "Searching for interfaces on $router... "
    if [catch {set ifLines [$router exec {show ip interface brief}]} errMsg] {
        die "failed.\n\n$self: $errMsg" 1
    }
    regsub -all {\\r} $ifLines {} ifLines
    puts "done."

    #==========================================================================
    # Configure the interfaces to be "no shut"
    #--------------------------------------------------------------------------
    puts -nonewline "Bringing up all interfaces on $router...\n"
    foreach ifLine [split $ifLines "\n"] {
        if { [regexp {^Interface} $ifLine] } {
            continue
        }
        if { [regexp {^[        ]*$} $ifLine] } {
            continue
        }
        regsub {[       ].*$} $ifLine {} if
	if [info exists INT($router)] {
	    if {[lsearch -exact $INT($router) [lindex [split $if {.:}] 0]] != -1 } {
	        continue
	    }
	}
        puts -nonewline [format {%-19s } $if]
        $router config "
            interface $if
            no shutdown
        "
        lappend INT($router) $if
    }
    puts "\n"
}

#==============================================================================
# Sleep enough for CDP information to percolate
#------------------------------------------------------------------------------
puts "Sleeping for 120 seconds for CDP information to percolate... \n"
sleep 120

#==============================================================================
# Loop thru each router in the testbed for the second pass
#------------------------------------------------------------------------------
foreach router $ROUTERS($testbed) {

    #==========================================================================
    # Find out the neighbours of this router and put them in a keyed list
    #--------------------------------------------------------------------------
    puts -nonewline "Determining neighbours of $router... "
    if [catch {set ifLines [$router exec {show cdp neighbors}]} errMsg] {
        die "failed.\n\n$self: $errMsg" 1
    }
    regsub -all {\\r} $ifLines {} ifLines
    
    foreach line [split $ifLines "\n"] {
        if { ![regexp "^($rtrRegexp)" $line] } {
            continue
        }
        regsub { ([^ ]+)$} $line {\1} line
        regsub $intRegexp $line {\1 \2\3 \4} line
        set neigh   [lindex $line 0]
        set if      [matchInt $router [lindex $line 1]]
        set neighIf [matchInt $neigh  [lindex $line 2]]
        if { [catch {keylget kL $router.$if.$neigh}] } {
            keylset kL $router.$if.$neigh {}
        }
        keylset kL $router.$if.$neigh "$neighIf"
        keylset mL $router.$if.map {}
    }
    puts "done."
}
puts {}

#==============================================================================
# Loop thru each router in the testbed for the third pass shutting off ifs
#------------------------------------------------------------------------------
foreach router $ROUTERS($testbed) {

    #==========================================================================
    # Configure the interfaces to be "no shut" except fddi
    #--------------------------------------------------------------------------
    puts -nonewline "Applying postconfig on $router... "
    if [catch { $router config $postconfig($router) } errMsg] {
        die "failed.\n\n$self: $errMsg" 1
    }
    puts "succeeded."
}

#==============================================================================
# Manipulate (massacre, rather) the keyed lists to form the MAP file
#------------------------------------------------------------------------------
puts -nonewline "Massacring data structures to MAP file... "
foreach router $ROUTERS($testbed) {
  foreach if [keylkeys kL $router] {
    if { [keylget mL $router.$if.map] == {} } {
      if { [llength [keylkeys kL $router.$if]] > 1 } {
        regsub {^([^0-9]+)([0-9].*)?([0-9])$} $if {\1\3} lan
        set lan "lan${lan}"
        foreach neigh [keylkeys kL $router.$if] {
          set neighIf [keylget kL $router.$if.$neigh]
          keylset mL $neigh.$neighIf.map "$lan"
        }
        keylset mL $router.$if.map "$lan"
      } else {
        set neigh   [keylkeys kL $router.$if]
        set neighIf [keylget kL $router.$if.$neigh]
        regsub -all {[^0-9/]} $if      {} if_
        regsub -all {[^0-9/]} $neighIf {} neighIf_
        keylset mL $router.$if.map     "${router}${if_}-${neigh}${neighIf_}"
        keylset mL $neigh.$neighIf.map "${router}${if_}-${neigh}${neighIf_}"
      }
    }
  }
}
puts "done."

#==============================================================================
# Print the MAP file
#------------------------------------------------------------------------------
puts -nonewline "Printing your ${testbed}.MAP file... "
if { [catch {set mId [open $mapFile w]} errMsg] } {
    die "failed.\n$errMsg"
}
puts $mId "set tb_servers {"
puts $mId "  { default $TFTPSERVERADDR }"
puts $mId "}"
puts $mId "set tb_map {"
foreach router $ROUTERS($testbed) {
  puts $mId "  { $router"
  puts $mId "    { Area: 0 }"
  foreach if [lsort -ascii $INT($router)] {
    if [catch {keylget mL $router.$if.map}] {
      puts $mId "    { [format {%-19s %s} $if NULL] }"
    } else {
      puts $mId "    { [format {%-19s %s} $if [keylget mL $router.$if.map]] }"
    }
  }
  puts $mId "  }"
}
puts $mId "}"
puts "done.\n"

#==============================================================================
# Remove the lock
#------------------------------------------------------------------------------
if { [file exists "${LOCK_DIR}/${testbed}.lock"] } {
    if { [catch {unlink "${LOCK_DIR}/${testbed}.lock"}] } {
        die "$self: ${LOCK_DIR}/${testbed}.lock: Failed to remove lockfile" 1 
    }
} else {
    die "$self: ${LOCK_DIR}/${testbed}.lock: lock file not found... hmm..." 1
}
