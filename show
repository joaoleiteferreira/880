#!/bin/sh
#******************************************************************
#*                                                                *
#*           Cisco Systems Proprietary Software                   *
#*   Not to be distributed without consent from Test Technology   *
#******************************************************************
#*
#  Tcl sees the next 5 lines as an assignment to variable 'kludge'.
#  for sh, the two shifts cancel the effect of the set, and then we
#  can run expect on this script.
set kludge { $*
shift
shift
if [ "X$AUTOTEST" = "X" ]; then
  echo Error: Environment variable AUTOTEST is not set.
  echo Please set the environment variable AUTOTEST to the root
  echo of the autotest tree.
  exit 1
fi
# cd $AUTOTEST/local/etc
exec $AUTOTEST/local/bin/expectk $0 $* &
exit
}

# Tcl code starts here.
set text {}
message .status_gui -text $text \
    -aspect 300 \
    -relief flat \
    -borderwidth 0 \
    -width 560
pack .status_gui
wm geom . +1+1
wm title . "Tests which will run"
wm withdraw .
bind .status_gui <1> "update_text"
update

after 1 update_text
after 1 update_window

proc tkerror err {
    global errorInfo
    set info $errorInfo
    if {[tk_dialog .tkerrorDialog "Error in Tcl Script" \
            "Error: $err" error 0 OK "See Stack Trace"] == 0} {
        return
    }
}

proc update_text {} {
  global text
  global env

  set l_text "==================================\n"
  set tst(IMAGE_DIR) $env(AUTOTEST)/local/images
  set files [readdir $tst(IMAGE_DIR)]
  set p 0
  foreach file $files {
  if [file exists $tst(IMAGE_DIR)/$file.suite] {
    if [file exists $tst(IMAGE_DIR)/$file.queue] {
      if ![file exists $tst(IMAGE_DIR)/$file.report] {
      if ![file exists $tst(IMAGE_DIR)/$file.abort] {
	append l_text $file\n
        }
      }
      }
     }
  }
   append l_text "==================================\n"
  set text $l_text
  .status_gui config -text $text
  after 60000 update_text
}

proc update_window {} {
    global text
 
    if { ![winfo ismapped .] && [string length $text]>0 } {
        wm deicon .
        .status_gui config -text $text
    } elseif { [winfo ismapped .] && [string length $text]<=0 } {
        wm withdraw .
    }
 
    after 1000 update_window
}

