#!/bin/sh

#==============================================================================
# This script can be used to telnet to a router for which a name is not
# specified. This script heavily depends on the way environment is set up for
# the regression group, tho it is not unportable. It basically builds an array
# from all the _device definitions it can find in an autotest environment.
#
# has option to telnet to all routers of a testbed by just specifying the
# testbed name
#
# -h option for help as always.
#------------------------------------------------------------------------------
# author: Kuntal Daftary
#==============================================================================

#==============================================================================
# Starter kludge
#------------------------------------------------------------------------------
set starter { ${1:+"$@"}
    shift
    shift
    export AUTOTEST
    AUTOTEST="${AUTOTEST-/autons/autotest}"
    exec $AUTOTEST/bin/expect -f $0 -- ${1:+"$@"}
}

#==============================================================================
# Find out the name of the program first and set the version info
#------------------------------------------------------------------------------
global cmd
regsub {.*/} [shift argv] {} cmd
set version 1.0
set author "Kuntal Daftary"
set revdate "Wed Oct 29 01:28:09 PST 1997"

#==============================================================================
# Procedure mytelnet
# input:  commstr - command string to be executed
# output: nothing
#------------------------------------------------------------------------------
proc mytelnet { commstr } {
    global cmd
    set comm [shift commstr]
    set args [split $commstr " "]
    if { [set pid [fork]] == 0 } {
        execl $comm $args
    } elseif { $pid == -1 } {
	puts "$cmd: Fatal error: fork failed for \"$commstr\""
	exit 1
    } else {
        tclx_wait 
    }
}

#==============================================================================
# Procedure fileisvalid
# input:  file - name of the file to check
#         need_to_warn - whether we should warn the user of problems
# output: if the file is invalid, program exits else the procedure returns 1
#------------------------------------------------------------------------------
proc fileisvalid { file need_to_warn } {
    global cmd
    if ![file exists $file] {
        if { $need_to_warn } { puts "$cmd: $file: File not found" }
	return 0
    }
    if ![file readable $file] {
        if { $need_to_warn } { puts "$cmd: $file: File not readable" }
	return 0
    }
    return 1
}

#==============================================================================
# Initialize variables
#------------------------------------------------------------------------------
set tblist {}
set routerlist {}

#==============================================================================
# Parse arguments
#------------------------------------------------------------------------------
while { [llength $argv] } {
    set word [shift argv]
    if [regexp -- -te?s?t?b?e?d? $word] {
        set tblist $argv
	break
    } elseif [regexp -- -ve?r?s?i?o?n? $word] {
        puts "$cmd Version $version by $author"
	puts "Last revision on: $revdate"
	exit 0
    } elseif [regexp -- -he?l?p? $word] {
        puts "Usage: $cmd <list of routers>                            "
        puts "       $cmd -testbed <list of testbeds>                  "
        puts "       $cmd <list of routers> -testbed <list of testbeds>"
        puts "       $cmd -version                                     "
        puts "       $cmd -help                                        "
        exit 0;
    } else {
	lappend routerlist $word
    }
}

#==============================================================================
# Check for existance of AUTOTEST environment variable
#------------------------------------------------------------------------------
if [info exists $env(AUTOTEST)] {
    puts "$cmd: AUTOTEST environment variable needs to be defined"
    exit 1
}

#==============================================================================
# Check for validity of CONFIG file and source it
#------------------------------------------------------------------------------
if [fileisvalid "$env(AUTOTEST)/local/CONFIG" 1] {
    if [catch "source $env(AUTOTEST)/local/CONFIG" errmsg] {
        puts "$cmd: \$AUTOTEST/local/CONFIG: Error sourcing file"
	puts "$errmsg"
        exit 1
    }
}

#==============================================================================
# If MASTER_INFO_MAP variable exists then check the validity of that file and
# source it. Then for each known testbed source all the information files
# listed under MASTER_INFO_MAP after checking its validity.
#------------------------------------------------------------------------------
if [info exists MASTER_INFO_MAP] {

    if [fileisvalid $MASTER_INFO_MAP 1] {
        if [catch "source $MASTER_INFO_MAP" errmsg] {
	    puts "$cmd: $MASTER_INFO_MAP: Error sourcing file"
	    exit 1
	}
    }
 
    if ![info exists TESTBEDS] {
        puts "$cmd: TESTBEDS variable not defined in \$AUTOTEST/local/CONFIG"
	exit 1
    }

    foreach tb $TESTBEDS {
        regsub "^\n*" $INFO_FILES(testbed,$tb) "" info_files
        regsub "\n*$" $info_files "" info_files
	set info_files_array [split $info_files "\n"]

	foreach file $info_files_array {
            # fileisvalid $file 0 [expr [lsearch $tblist $tb] + 1]
	    if [catch "source $file" errmsg] {
		puts "$cmd: $file: Error sourcing file"
	        puts "$errmsg"
	    }
	}
	if [info exists device_file] {
            if [fileisvalid $device_file 0 0] {
	        if [catch "source $device_file" errmsg] {
		    puts "$cmd: $device_file: Error sourcing file"
	        }
	    }
	}
    }
}

#==============================================================================
# Append the routers from the testbeds provided as arguments to the routers
# list provided as arguments
#------------------------------------------------------------------------------
foreach tb $tblist {
    set routerlist [concat $routerlist $ROUTERS($tb)]
}

#==============================================================================
# Open a telnet session for each router in the router list
#------------------------------------------------------------------------------
foreach router $routerlist {
    if [info exists _device($router)] {
	puts "$cmd: $router: Opening telnet session...\n"
	mytelnet $_device($router)
    } else {
	puts "$cmd: $router: No such router"
    }
}
