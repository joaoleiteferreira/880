#!/nfs/engweb/bin/perl

#==============================================================================
# Set stuff for using system and local perl libraries
#------------------------------------------------------------------------------
use Oraperl;
#eval "use Oraperl" if $] > 5.002;

#==============================================================================
# Initialize variables
#------------------------------------------------------------------------------
($cmd = $0) =~ s:.*/::;
$ENV{ORACLE_HOME} = "/dev/null";
$ENV{TNS_ADMIN} = "/nfs/engweb/oracle/sqlnet";

require "/auto/engweb/cgi/protected-cgi-bin/sisu-reg/variables.lib";

$months = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec";
undef $dir;
$showArchive = 0;
$showImages  = 0;
$showTbs     = 0;
$showVersion = 0;
$insertInDb  = 0;

#==============================================================================
# Basic options parsing and validation
#------------------------------------------------------------------------------
while (@ARGV) {
    $word = shift;
    if ($word =~s/^-//) {
        $option = $word;
        if ($option =~ /^dir?$/) {
            $dir = shift;
            die "$cmd: -$option: Missing directory name\n" unless defined $dir;
        } elsif ($option =~ /^re?q?u?e?s?t?$/) {
            $caseid = shift;
            die "$cmd: -$option: Missing request id\n" unless defined $caseid;
        } elsif ($option =~ /^ar?c?h?i?v?e?$/) {
            $showArchive = 1;
        } elsif ($option =~ /^im?a?g?e?s?$/) {
            $showImages = 1;
        } elsif ($option =~ /^te?s?t?b?e?d?$/) {
            $showTbs = 1;
        } elsif ($option =~ /^ve?r?s?i?o?n?$/) {
            $showVersion = 1;
        } elsif ($option =~ /^dat?a?b?a?s?e?$/) {
            $insertInDb = 1;
        } elsif ($option =~ /^he?l?p?$/) {
            print "\nUsage: $cmd [options] <file>\n";
            print "       $cmd -help\n\n";
            print "where options include:\n\n";
            print "-archive  Print the list of important archive files     \n";
	    print "-database Insert extracted results into database also   \n";
            print "-dir      Directory from where to pick the summary files\n";
            print "          [default: \$AUTOTEST/local/images]\n";
            print "-images   Print the list of all images used in testing  \n";
            print "-request  Which request id to generate the results for? \n";
            print "-testbed  Print the list of testbeds used               \n";
            print "-version  Print the versions of images used             \n";
            exit 0;
        } else {
            die "$cmd: -$option: unknown switch\n";
        }
    } else {
        push (@files, $word);
    }
}


if (! defined $caseid) {
    print "Enter request id: ";
    $caseid = <STDIN>; print "\n";
	chomp;
    $caseid =~ s/\s//g;
    die "$cmd: Missing request id\n" if ($caseid =~ /^\s*$/);
}

print "\n";
#==============================================================================
# Resorting to defaults and validating them
#------------------------------------------------------------------------------
if (! defined $dir) {
    die "$cmd: AUTOTEST environment variable needs to be defined\n"
        unless $ENV{AUTOTEST};
    $dir = "$ENV{AUTOTEST}/local/images";
}


die "$cmd: $dir: No such directory\n" unless (-d $dir);
die "$cmd: $dir: Directory not readable\n" unless (-r $dir);
die "$cmd: $dir: Cannot change to directory\n" unless (-x $dir);

if ($#files == -1) {
    opendir(DIR, $dir) || die "$cmd: $dir: $!";
 ## Pedro: look into all file or just ther request_id ones    
@files = grep { /^.*$caseid\.summary.*$/ } readdir(DIR);
	   #@files = grep { /^.*summary.*$/ } readdir(DIR);
    closedir DIR;
}

for (@files) {
    s/^/$dir\//;

    #==========================================================================
    # Validate the given files for existance and readability
    #--------------------------------------------------------------------------
    die "$cmd: $_: File not found" unless ( -f $_ );
    die "$cmd: $_: File not readable" unless ( -r $_ );
}

#==============================================================================
# Get the start time of the test from each file so that they can be sorted
# chronologically and opened in that order for later processing
#------------------------------------------------------------------------------
foreach $file (@files) {

    #==========================================================================
    # Validate the given files for existance, readability and openability
    #--------------------------------------------------------------------------
    die "$cmd: Extract module: $file: File not found" unless ( -f $file );
    die "$cmd: Extract module: $file: File not readable" unless ( -r $file );
    die "$cmd: Extract module: $file: Open failed" unless open (FILE, $file);

    undef $mon; undef $time; undef $case;
    #==========================================================================
    # Read the files till we get the start time string, process that string
    # and put that value in a assoc array with the filename for later
    # processing, and close the file.
    #--------------------------------------------------------------------------
    while (<FILE>) {
        if ( /^Start Time.*: ([JFMASOND][aepuco][nbrylgptvc])-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)/) {
           $mon = index ($months, $1) / 4 + 1;
            $time = "19$3$mon$2$4$5$6";
        } elsif (/^Reason.*: (.+)$/) {
            $case = $1;
            $case =~ s/\s//g;
        }
    }
    next if ($case ne $caseid);
    if ($filetime{$time}) {
        ++$time;
        $filetime{$time} = $file;
    } else {
        $filetime{$time} = $file;
    }
    close (FILE);
}

$maxNameLen = length($caseid);
foreach $time (sort keys %filetime) {
    $change = 0;
    undef $suite; undef $archive; undef $testbed;
    open (FILE, $filetime{$time});
    while (<FILE>) {
        if (($insertInDb || $showArchive) && /^Archive File: (.+)$/) {
            $archive = $1;
	    $archive =~ s/\n*$//;
        } elsif (/^Image.*: (\S+) .*$/) {
            $suite = $1;
        } elsif (/^Testbed.*: (.+)$/) {
            $testbed = $1;
        } elsif (/^-{34,34}DIAGNOSTICS-{34,34}/) {
            last;
        }
    }
    while (<FILE>) {
        next if (/^\s*\#/);
        if ((/^Test Id: .*:(.*)/) || (/^Test Id: (.*)/)) {
            $id = $1;
            do { $_ = <FILE>; } until (/Status: (.*)/);
            $change |= ( $RESULT{$suite}{$id} eq $1 ? 0 : 1 );
            $RESULT{$suite}{$id} = $1;
        } else {
            next;
        }
    }
    $maxNameLen=($maxNameLen > length($suite) ? $maxNameLen : length($suite));

    #==========================================================================
    # Get the archive info if we are asked to do so and find the common part in
    # all the archive file names
    #-------------------------------------------------------------------------- 
    if ($change) {
        push @{ $ARCHIVES{$suite} }, $archive;
        push @{ $TESTBEDS{$suite} }, $testbed;
    }
    close (FILE);
}

#==============================================================================
# Show the images if we are asked to do so
#------------------------------------------------------------------------------
if ($showImages) {
  foreach $suite ( sort keys %RESULT ) {
    $file = "$dir/$suite.queue";

    #==========================================================================
    # Validate the given files for existance, readability and openability
    #--------------------------------------------------------------------------
    if ( -f $file ) {
        warn "$cmd: $file: File not found\n";
	next;
    }
    if ( -r $file ) {
        warn "$cmd: $file: File not readable\n";
	next;
    }
    if (! open (FILE, $file)) { 
        warn "$cmd: $file: Could not open file\n";
	next;
    }

    while (<FILE>) {
      chop; next if (! /^\s*boot\s*:/); s/^\s*boot\s*:\s*//; s/\s+/ /g;
      ($router, $image) = split(" ");
      ($junk, $type, $junk) =  split("-", $image);
      $IMAGES{$image}++;
    }
    close (FILE);
  }
  print "IMAGES USED:\n------------\n";
  for (sort keys %IMAGES) {
    print "$_\n";
    if ($showVersion) {
      $file = "$ENV{AUTOTEST}/local/images/aux_images/$_";
      warn "$cmd: Version module: $file: not found" unless ( -f $file );
      warn "$cmd: Version module: $file: not readable" unless ( -r $file );
      warn "$cmd: Version module: $file: open failed" unless open (FILE, $file);
      while (<FILE>) {
        if (/Compiled.*Version ([^ \t,]*)/) {
            push (@version, $1);
        }
      }
      close (FILE);
    }
  }
  print "\n";
}

if ($showVersion) {
  print "VERSIONS:\n---------\n", join ("\n", @version), "\n\n";
}

if ($showTbs) {
  print "TESTBEDS USED:\n--------------\n";
  for (keys %TESTBEDS) {
    foreach $tbs ( @{ $TESTBEDS{$_} } ) {
      $TBuniq{$tbs}++;
    }
  }
  print join("\n", keys %TBuniq), "\n\n";
}

#==============================================================================
# Print the most important header of all times
#------------------------------------------------------------------------------
print "REPORT:\n", "-"x7, "\n", "="x79, "\n";
print "$caseid  ", " "x($maxNameLen-length($caseid));
print "Pass  Fail  Abort  Never  Total  Comments\n";
print "-"x79, "\n";

#==============================================================================
# Start off!
#------------------------------------------------------------------------------
if ($insertInDb) {
    $lda = &ora_login('', $ORACLE_LOGIN, '') 
        || die "$cmd: Database module: ora_login: $ora_errstr";
}
foreach $suite ( sort keys %RESULT ) {
    $pass = $fail = $abrt = $nran = $totl = 0;
    foreach $id ( keys %{ $RESULT{$suite} } ) {
        ++$pass if ($RESULT{$suite}{$id} eq "passed");
        ++$fail if ($RESULT{$suite}{$id} eq "failed");
        ++$abrt if ($RESULT{$suite}{$id} eq "aborted");
        ++$nran if ($RESULT{$suite}{$id} eq "never_ran");
        ++$totl;
    }
    ($actualSuite = $suite) =~ s/-\w+$//;
    printf "%-${maxNameLen}s  %4d  %4d  %5d  %5d  %5d\n",
        $actualSuite, $pass, $fail, $abrt, $nran, $totl;
    if ($insertInDb) {
        $tbList = join(" ", @{ $TESTBEDS{$suite} } );
	#for ($arch_cnt = 0; $arch_cnt <= $#{ $ARCHIVES{$suite} }; ++$arch_cnt) {
	#    ${ $ARCHIVES{$suite} }[$arch_cnt] =~ s/^\s*//;
	#    ${ $ARCHIVES{$suite} }[$arch_cnt] =~ s/\s*$//;
	#}
        $arList = join("\n", @{ $ARCHIVES{$suite} } );
        $csr = &ora_open($lda, <<eoSql) || die "$cmd: Database module: ora_open: $ora_errstr";
UPDATE RESULTS
SET    PASSED = '$pass', FAILED = '$fail', ABORTED = '$abrt',
       NEVER_RAN = '$nran', TOTAL = '$totl', TESTBEDS = '$tbList',
       ARCHIVES = '$arList'
WHERE  REQUEST_ID = '$caseid'
       AND
       SUITE = '$actualSuite'
eoSql
        do ora_close($csr)
	    || die "$cmd: Database module: ora_close: $ora_errstr";
    }
}
if ($insertInDb) {
    do ora_logoff($lda)
        || die "$cmd: Database module: ora_logoff: $ora_errstr\n";
}
print "="x79, "\n\n";

if ($showArchive || $insertInDb) {
  print "ARCHIVES:\n", "-"x9, "\n";
  for (keys %ARCHIVES) {
    foreach $arch ( @{ $ARCHIVES{$_} } ) {
      $archComm = $arch if (! defined $archComm || $archComm !~ /\S/);
      if ("$archComm\001$arch" =~ /([^\001]*\/)[^\001]*\001\1[^\001]*/){
        $archComm = $1;
      }
    }
  }
  print "$archComm\n";
  for (keys %ARCHIVES) {
    foreach $arch ( @{ $ARCHIVES{$_} } ) {
      $arch =~ s:$archComm::;
      print "    $arch\n";
    }
  }
}
